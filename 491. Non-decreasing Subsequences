#Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.
#Example 1:

#Input: nums = [4,6,7,7]
#Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
#Example 2:

#Input: nums = [4,4,3,2,1]
#Output: [[4,4]]

class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        result = []
        self.backtracking(nums,0,[],result)
        return result 
    def backtracking(self,nums,startIdx,path,result):
        if len(path) > 1:
            result.append(path[:])
        used = set()
        for i in range(startIdx,len(nums)):
            if (path and path[-1] > nums[i]) or nums[i] in used:
                continue 
            used.add(nums[i])
            path.append(nums[i])
            self.backtracking(nums,i+1,path,result)
            path.pop()
